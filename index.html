<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Notepad</title>
  <link rel="icon" href="data:,">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0 auto;
      padding: 1rem;
      max-width: 60ch;
    }
    textarea {
      width: 100%;
      min-height: 70vh;
      font-size: clamp(1rem, 2.5vw, 1.125rem);
      box-sizing: border-box;
      white-space: pre;
      overflow-x: auto;
    }
    h1 { text-align: center; }
    #statusRow { font-size: 0.875rem; margin-top: 5px; display: flex; align-items: center; gap: 0.5em; }
    #dirtyIndicator {
      width: 0.75em;
      height: 0.75em;
      border-radius: 50%;
      background: green;
      display: inline-block;
    }
    #toolbar {
      display: flex;
      gap: 0.25em;
      margin: 0.5em 0;
    }
    #toolbar button {
      width: 2em;
      height: 2em;
      font-size: 1.25rem;
      line-height: 2em;
      text-align: center;
      background: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 0;
      cursor: pointer;
    }
    #gaBtn {
      color: #4285F4;
      font-weight: bold;
    }
    #o4Btn {
      color: #10a37f;
      font-weight: bold;
    }
    #geminiResult {
      font-size: clamp(0.875rem, 2vw, 1rem);
      line-height: 2em;
      margin-left: 0.5em;
      flex: 1;
      overflow-wrap: anywhere;
    }
    @media (max-width: 599px) {
      #toolbar { flex-wrap: wrap; }
      #geminiResult {
        flex-basis: 100%;
        margin-left: 0;
      }
    }
    @media (min-width: 600px) {
      body { max-width: 800px; }
      textarea { min-height: 80vh; }
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <button id="bulletBtn" type="button" aria-label="Add bullet">&bull;</button>
    <button id="outdentBtn" type="button" aria-label="Remove indent">‚á§</button>
    <button id="indentBtn" type="button" aria-label="Indent">‚á•</button>
    <button id="undoBtn" type="button" aria-label="Undo">‚Ü∫</button>
    <button id="redoBtn" type="button" aria-label="Redo">‚Üª</button>
    <button id="cutLineBtn" type="button" aria-label="Cut line">‚úÇÔ∏è</button>
    <button id="wrapBtn" type="button" aria-label="Toggle wrap">‚Ü©</button>
    <button id="saveBtn" type="button" aria-label="Save to Supabase">üíæ</button>
    <button id="loadBtn" type="button" aria-label="Load from Supabase">‚≠Æ</button>
    <button id="geminiBtn" type="button" aria-label="Gemini">AI</button>
    <button id="gaBtn" type="button" aria-label="Copy to Google AI">G</button>
    <button id="o4Btn" type="button" aria-label="Copy to ChatGPT o4">o4</button>
    <span id="geminiResult"></span>
  </div>
  <textarea id="note" placeholder="Start typing..." wrap="off"></textarea>
  <div id="statusRow"><span id="dirtyIndicator"></span><span id="status"></span></div>
  <script>
    const textarea = document.getElementById('note');
    const status = document.getElementById('status');
    const geminiResult = document.getElementById('geminiResult');
    const dirtyIndicator = document.getElementById('dirtyIndicator');
    const wrapBtn = document.getElementById('wrapBtn');
    const STORAGE_KEY = 'notepad-content';
    const WRAP_KEY = 'notepad-wrap';
    const SERVER_URL = 'https://testing-39z9.onrender.com';
    const SUPABASE_URL = 'https://kakhtozhcphemmmyclmz.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imtha2h0b3poY3BoZW1tbXljbG16Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTAzNTQ5MzksImV4cCI6MjA2NTkzMDkzOX0.Oe8GPcFpUWeDH1CG2lN2TQ8F4m4uVqq15jlhw4f-R0g';
    const PIN_KEY = "notes-pin";
    const DEFAULT_PIN = '0043';
    const undoStack = [];
    const redoStack = [];
    let lastValue = '';
    const MAX_STACK = 50;
    let dirty = false;
    let wrapped = false;
    let statusTimer;

    function getPin() {
      let pin = localStorage.getItem(PIN_KEY);
      if (!pin) {
        pin = prompt('Enter PIN');
        if (!pin) return null;
        localStorage.setItem(PIN_KEY, pin);
      }
      return pin || null;
    }

    function linkify(text) {
      const escapeMap = { '&': '&amp;', '<': '&lt;', '>': '&gt;' };
      const escaped = text.replace(/[&<>]/g, c => escapeMap[c] || c);
      return escaped.replace(/(https?:\/\/\S+)/g,
        url => `<a href="${url}" target="_blank" rel="noopener">${url}</a>`);
    }

    function loadLocal() {
      textarea.value = localStorage.getItem(STORAGE_KEY) || '';
      lastValue = textarea.value;
    }

    async function saveRemote() {
      status.textContent = 'Saving...';
      try {
        const res = await fetch(`${SUPABASE_URL}/rest/v1/notes`, {
          method: 'POST',
          headers: {
            apikey: SUPABASE_KEY,
            Authorization: 'Bearer ' + SUPABASE_KEY,
            'Content-Type': 'application/json',
            Prefer: 'resolution=merge-duplicates'
          },
          body: JSON.stringify([{ id: 1, content: textarea.value }])
        });
        if (res.ok) {
          status.textContent = 'Saved';
        } else {
          if (res.status === 401) {
            alert('‚ö†Ô∏è Save failed: unauthorized. Supabase permissions may be missing or misconfigured.');
          } else {
            console.error('Save error', res.status, await res.text());
            status.textContent = 'Save failed';
          }
        }
      } catch (err) {
        status.textContent = 'Save error';
      }
    }

    async function loadRemote() {
      status.textContent = 'Loading...';
      try {
        const res = await fetch(`${SUPABASE_URL}/rest/v1/notes?id=eq.1&select=content`, {
          headers: { apikey: SUPABASE_KEY, Authorization: 'Bearer ' + SUPABASE_KEY }
        });
        if (res.ok) {
          const data = await res.json();
          const content = data[0]?.content || '';
          textarea.value = content;
          lastValue = content;
          save();
          status.textContent = 'Loaded';
        } else {
          status.textContent = 'Load failed';
        }
      } catch (err) {
        status.textContent = 'Load error';
      }
    }

    function updateDirtyIndicator() {
      dirtyIndicator.style.background = dirty ? 'red' : 'green';
    }

    function pushUndo(state) {
      undoStack.push(state);
      if (undoStack.length > MAX_STACK) undoStack.shift();
      redoStack.length = 0;
    }

    function undo() {
      if (!undoStack.length) return;
      redoStack.push(textarea.value);
      if (redoStack.length > MAX_STACK) redoStack.shift();
      const value = undoStack.pop();
      textarea.value = value;
      lastValue = value;
      save();
    }

    function redo() {
      if (!redoStack.length) return;
      undoStack.push(textarea.value);
      if (undoStack.length > MAX_STACK) undoStack.shift();
      const value = redoStack.pop();
      textarea.value = value;
      lastValue = value;
      save();
    }

    function setWrapping(on) {
      wrapped = on;
      textarea.style.whiteSpace = on ? 'pre-wrap' : 'pre';
      textarea.setAttribute('wrap', on ? 'soft' : 'off');
      localStorage.setItem(WRAP_KEY, on ? '1' : '0');
    }

    function toggleWrap() {
      setWrapping(!wrapped);
    }

    function toggleBullet() {
      pushUndo(textarea.value);
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const text = textarea.value;

      let lineStart = text.lastIndexOf('\n', start - 1) + 1;
      let lineEnd = text.indexOf('\n', end);
      if (lineEnd === -1) lineEnd = text.length;

      const before = text.slice(0, lineStart);
      const after = text.slice(lineEnd);
      const lines = text.slice(lineStart, lineEnd).split('\n');
      const bullet = '‚Ä¢ ';
      const toggled = lines
        .map(l => {
          const m = l.match(/^(\s*)(.*)$/);
          let indent = m[1];
          let rest = m[2];
          if (rest.startsWith(bullet)) {
            rest = rest.slice(bullet.length);
            if (indent.startsWith('    ')) indent = indent.slice(4);
            else if (indent.startsWith('\t')) indent = indent.slice(1);
            return indent + rest;
          }
          indent = '    ' + indent;
          return indent + bullet + rest;
        })
        .join('\n');

      textarea.value = before + toggled + after;
      textarea.selectionStart = lineStart;
      textarea.selectionEnd = lineStart + toggled.length;
      lastValue = textarea.value;
      save();
    }

    function indentSelection() {
      pushUndo(textarea.value);
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const scrollPos = textarea.scrollTop;
      const text = textarea.value;

      let lineStart = text.lastIndexOf('\n', start - 1) + 1;
      let lineEnd = text.indexOf('\n', end);
      if (lineEnd === -1) lineEnd = text.length;

      const before = text.slice(0, lineStart);
      const after = text.slice(lineEnd);
      const lines = text.slice(lineStart, lineEnd).split('\n');
      const indented = lines.map(l => '    ' + l).join('\n');

      textarea.value = before + indented + after;
      textarea.focus();
      textarea.selectionStart = lineStart;
      textarea.selectionEnd = lineStart + indented.length;
      textarea.scrollTop = scrollPos;
      lastValue = textarea.value;
      save();
    }

    function outdentSelection() {
      pushUndo(textarea.value);
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const scrollPos = textarea.scrollTop;
      const text = textarea.value;

      let lineStart = text.lastIndexOf('\n', start - 1) + 1;
      let lineEnd = text.indexOf('\n', end);
      if (lineEnd === -1) lineEnd = text.length;

      const before = text.slice(0, lineStart);
      const after = text.slice(lineEnd);
      const lines = text.slice(line... (rest of script unchanged) ...
  </script>
</body>
</html>
